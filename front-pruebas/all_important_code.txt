auth.py:
from flask import Blueprint, request, jsonify
from flask_jwt_extended import create_access_token, jwt_required, get_jwt_identity
from werkzeug.security import check_password_hash
from .db import User, Student, Teacher, Academy
from datetime import timedelta
import re
auth_bp = Blueprint('auth', __name__)

def detect_identifier_type(identifier):
    # Detectar si es una boleta (estudiante)
    print(identifier)
    if identifier.isdigit() and len(identifier) == 10 and identifier.startswith(('20', '19')):
        return 'student'
    # Detectar si es un RFC (profesor)
    elif re.match(r'^[A-ZÑ&]{3,4}\d{6}[A-Z0-9]{3}$', identifier, re.IGNORECASE):
        return 'teacher'
    # Detectar si es una academy_id (asumiendo que es un número entero pero no una boleta)
    elif identifier.isdigit() and len(identifier) == 8:
        return 'academy'
    # Detectar si es un administrador (por ejemplo, 'admin' o un username específico)
    elif identifier.lower() in ['admin', 'administrator']:
        return 'admin'
    else:
        return None

# Función auxiliar para obtener el usuario actual
def get_current_user():
    identifier = get_jwt_identity()
    user = None

    # Intentar obtener al usuario según el tipo de identificador
    user_type = detect_identifier_type(identifier)
    if user_type == 'student':
        student = Student.query.filter_by(boleta=identifier).first()
        if student:
            user = student.user
    elif user_type == 'teacher':
        teacher = Teacher.query.filter_by(rfc=identifier.upper()).first()
        if teacher:
            user = teacher.user
    elif user_type == 'academy':
        academy = Academy.query.filter_by(academy_id=int(identifier)).first()
        if academy:
            user = academy.main_teacher.user
    elif user_type == 'admin':
        user = User.query.filter_by(username=identifier).first()

    return user

# Endpoint para iniciar sesión
@auth_bp.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    if not data or 'identifier' not in data or 'password' not in data:
        return jsonify({"error": "Datos incompletos"}), 400

    identifier = data['identifier']
    password = data['password']

    # Detectar el tipo de usuario
    user_type = detect_identifier_type(identifier)
    print(user_type)
    if not user_type:
        return jsonify({"error": "Identificador no válido"}), 400

    # Buscar al usuario y verificar la contraseña
    user = None
    if user_type == 'student':
        student = Student.query.filter_by(boleta=identifier).first()
        if student:
            user = student.user
            print("el usuario es student ", user)
    elif user_type == 'teacher':
        teacher = Teacher.query.filter_by(rfc=identifier.upper()).first()
        if teacher:
            user = teacher.user
            print("el usuario es teacher ", user)
    elif user_type == 'academy':
        academy = Academy.query.filter_by(academy_id=int(identifier)).first()
        if academy:
            user = academy.main_teacher.user
            print("el usuario es academy ", user)
    elif user_type == 'admin':
        user = User.query.filter_by(username=identifier).first()
        print("el usuario es admin ", user)
    else:
        return jsonify({"error": "Tipo de usuario no reconocido"}), 400

    print(password)

    # Verificar si el usuario existe y la contraseña es correcta
    if user is None or not check_password_hash(user.password, password):
        return jsonify({"error": "Credenciales inválidas"}), 401

    # Generar el token JWT usando el identificador especializado
    access_token = create_access_token(identity=identifier, expires_delta=timedelta(days=2))

    return jsonify({
        "message": "Inicio de sesión exitoso",
        "access_token": access_token,
        "active": user.active,
        "user_type": user.role.name,
        "user_id": identifier  # Enviamos el identificador especializado
    }), 200


# Endpoint para verificar si la sesión está activa
@auth_bp.route('/verify-session', methods=['GET'])
@jwt_required()
def verify_session():
    user = get_current_user()
    if user:
        return jsonify({
            'authenticated': True,
            'user_type': user.role.name,
            'active': user.active
        }), 200
    else:
        return jsonify({
            'authenticated': False
        }), 401

# Endpoint para cerrar sesión
@auth_bp.route('/logout', methods=['POST'])
@jwt_required()
def logout():
    # No se requiere ninguna acción adicional en el servidor
    return jsonify({"message": "Cierre de sesión exitoso"}), 200

# Endpoint para restablecer contraseña
@auth_bp.route('/forget_password', methods=['POST'])
def forget_password():
    try:
        data = request.get_json()
        if 'username' not in data:
            return jsonify({"error": "El campo 'username' es obligatorio"}), 400

        user = User.query.filter_by(username=data['username']).first()
        if not user:
            return jsonify({"error": "Usuario no encontrado"}), 404

        # Aquí puedes implementar la lógica para enviar un correo de recuperación
        # Por ejemplo, utilizando Flask-Mail o cualquier otro servicio de correo

        return jsonify({"message": "Correo de recuperación enviado", "email": user.email}), 200

    except Exception as e:
        return jsonify({"error": "Error en el servidor", "details": str(e)}), 500

decorators.py:
from functools import wraps
from flask import jsonify
from flask_jwt_extended import get_jwt_identity, jwt_required
from .db import User, Student, Teacher, Academy, Role

def role_required(*roles):
    def decorator(f):
        @wraps(f)
        @jwt_required()  # Asegura que el usuario esté autenticado con JWT
        def decorated_function(*args, **kwargs):
            # Obtener la identidad desde el token JWT
            identifier = get_jwt_identity()
            user = None

            # Buscar al usuario según el identificador
            student = Student.query.filter_by(boleta=identifier).first()
            if student:
                user = student.user
            else:
                teacher = Teacher.query.filter_by(rfc=identifier).first()
                if teacher:
                    user = teacher.user
                else:
                    # Si es academia, el identificador será el academy_id
                    academy = Academy.query.filter_by(academy_id=identifier).first()
                    if academy:
                        user = academy.main_teacher.user
                    else:
                        # Asumimos que el administrador se autentica con su user_id
                        user = User.query.filter_by(id=identifier).first()

            if not user:
                return jsonify({"error": "Usuario no encontrado"}), 404
            if user.role_id not in roles:
                return jsonify({"error": "Acceso denegado"}), 403

            return f(*args, **kwargs)
        return decorated_function
    return decorator

events.py:
from flask import Blueprint, request, jsonify
from .decorators import role_required
from .db import db, APILog
from flask_jwt_extended import jwt_required
from datetime import datetime

logs_bp = Blueprint('logs_bp', __name__)

# Obtener logs filtrados por user_identifier, container_name y rango de fechas opcional
@logs_bp.route('/logs', methods=['GET'])
@jwt_required()
@role_required(0)  # Solo usuarios con rol "Administrador" pueden acceder
def get_logs():
    user_identifier = request.args.get('user_identifier')
    container_name = request.args.get('container_name')
    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')
    
    # Crear la consulta base
    query = APILog.query
    
    # Filtrar por user_identifier o container_name si están presentes
    if user_identifier:
        query = query.filter_by(user_identifier=user_identifier)
    if container_name:
        query = query.filter_by(container_name=container_name)
    
    # Filtrar por rango de fechas si están presentes
    if start_date:
        try:
            start_date = datetime.strptime(start_date, "%Y-%m-%d")
            query = query.filter(APILog.timestamp >= start_date)
        except ValueError:
            return jsonify({"error": "Formato de fecha inválido para start_date. Use YYYY-MM-DD"}), 400

    if end_date:
        try:
            end_date = datetime.strptime(end_date, "%Y-%m-%d")
            query = query.filter(APILog.timestamp <= end_date)
        except ValueError:
            return jsonify({"error": "Formato de fecha inválido para end_date. Use YYYY-MM-DD"}), 400

    # Ejecutar la consulta y obtener los resultados
    logs = query.all()
    
    # Serializar los logs para el JSON de respuesta
    logs_data = [{
        "id": log.id,
        "user_identifier": log.user_identifier,
        "operation": log.operation,
        "container_name": log.container_name,
        "object_name": log.object_name,
        "status_code": log.status_code,
        "timestamp": log.timestamp,
        "error_message": log.error_message
    } for log in logs]

    return jsonify(logs_data), 200
file.py:
# files.py
# Módulo para el manejo de archivos y directorios

import os
import base64
import hashlib
import threading
import time
import uuid
import zipfile
from flask import Blueprint, after_this_request, request, jsonify, send_file
from pathlib import Path
from flask_jwt_extended import get_jwt_identity, jwt_required
from .db import db, User, Student, Teacher, Academy
from .path import store_path, zip_path
from .logs import log_api_request

file_bp = Blueprint('file_bp', __name__)

# Tamaño máximo permitido para archivos/chunks (en bytes)
MAX_FILE_SIZE = 500 * 1024 * 1024  # 500 MB

# Función auxiliar para obtener el usuario actual
def get_current_user():
    identifier = get_jwt_identity()
    user = None

    # Buscar al usuario según el identificador
    student = Student.query.filter_by(boleta=identifier).first()
    if student:
        user = student.user
    else:
        teacher = Teacher.query.filter_by(rfc=identifier).first()
        if teacher:
            user = teacher.user
        else:
            academy = Academy.query.filter_by(academy_id=identifier).first()
            if academy:
                user = academy.main_teacher.user
            else:
                # Asumimos que los administradores se autentican con user.id
                user = User.query.filter_by(id=identifier, role_id=0).first()

    return user

# Función para obtener el directorio base del usuario
def get_user_directory(user):
    return os.path.join(store_path, str(user.username))

# Función para asegurar rutas y prevenir path traversal
def secure_path(user_directory, relative_path):
    # Combinar y normalizar la ruta
    full_path = os.path.normpath(os.path.join(user_directory, relative_path))
    # Verificar que la ruta esté dentro del directorio del usuario
    if os.path.commonprefix([full_path, user_directory]) != user_directory:
        raise ValueError("Intento de acceso no autorizado fuera del directorio asignado")
    return full_path

# Función para verificar si un archivo ya existe y asignar un nuevo nombre si es necesario
def get_unique_file_path(directory, file_name):
    base_name, extension = os.path.splitext(file_name)
    counter = 1
    new_file_path = os.path.join(directory, file_name)

    # Itera hasta encontrar un nombre de archivo único
    while os.path.exists(new_file_path):
        new_file_name = f"{base_name}({counter}){extension}"
        new_file_path = os.path.join(directory, new_file_name)
        counter += 1

    return new_file_path

# Función que obtiene la estructura de directorios y archivos recursivamente
def get_directory_structure(root_dir):
    structure = {'folders': [], 'files': []}

    for item in root_dir.iterdir():
        if item.is_dir():
            structure['folders'].append(item.name)
        elif item.is_file():
            structure['files'].append(item.name)

    return structure

# Ruta para subir un solo archivo
@file_bp.route('/upload/single', methods=['POST'])
@jwt_required()
def upload_file():
    user = get_current_user()
    if not user:
        return jsonify({"error": "Usuario no autenticado"}), 401

    data = request.get_json()
    if not data or 'file' not in data or 'filename' not in data:
        log_api_request(get_jwt_identity(), "Subida de archivo fallida - Datos incompletos", "uploads", "unknown", 400)
        return jsonify({"error": "Datos incompletos"}), 400

    file_data = data['file']
    file_name = data['filename']
    file_path = data.get('path', '')

    try:
        file_bytes = base64.b64decode(file_data)
        if len(file_bytes) > MAX_FILE_SIZE:
            log_api_request(get_jwt_identity(), "Archivo demasiado grande", file_path, file_name, 400)
            return jsonify({"error": "El archivo es demasiado grande"}), 400

        user_directory = get_user_directory(user)
        save_directory = secure_path(user_directory, file_path)
        os.makedirs(save_directory, exist_ok=True)

        save_path = os.path.join(save_directory, file_name)

        # Verificar si el archivo ya existe y obtener una ruta única
        save_path = get_unique_file_path(save_directory, file_name)

        with open(save_path, 'wb') as file:
            file.write(file_bytes)

        log_api_request(get_jwt_identity(), "Subida de archivo exitosa", file_path, file_name, 200)
        return jsonify({"message": "Archivo cargado correctamente"}), 200

    except ValueError as ve:
        log_api_request(get_jwt_identity(), "Intento de acceso no autorizado", file_path, file_name, 403)
        return jsonify({"error": str(ve)}), 403
    except Exception as e:
        log_api_request(get_jwt_identity(), "Error en la subida de archivo", file_path, file_name, 500, error_message=str(e))
        return jsonify({"error": "Error interno del servidor"}), 500

# Ruta para subir múltiples archivos
@file_bp.route('/upload/lot', methods=['POST'])
@jwt_required()
def upload_multiple_files():
    user = get_current_user()
    if not user:
        return jsonify({"error": "Usuario no autenticado"}), 401

    data = request.get_json()
    if not data or 'files' not in data:
        log_api_request(get_jwt_identity(), "Subida múltiple fallida - No se encontraron archivos", "uploads", "none", 400)
        return jsonify({"error": "No se encontraron archivos"}), 400

    files = data['files']
    file_path = data.get('path', '')

    try:
        user_directory = get_user_directory(user)
        save_directory = secure_path(user_directory, file_path)
        os.makedirs(save_directory, exist_ok=True)

        for file_info in files:
            if not file_info.get('file') or not file_info.get('filename'):
                log_api_request(get_jwt_identity(), "Subida múltiple fallida - Datos incompletos en un archivo", file_path, "unknown", 400)
                return jsonify({"error": "Datos incompletos en uno de los archivos"}), 400

            file_data = file_info['file']
            file_name = file_info['filename']

            file_bytes = base64.b64decode(file_data)
            if len(file_bytes) > MAX_FILE_SIZE:
                log_api_request(get_jwt_identity(), f"Archivo demasiado grande - {file_name}", file_path, file_name, 400)
                return jsonify({"error": f"El archivo {file_name} es demasiado grande"}), 400

            save_path = os.path.join(save_directory, file_name)
            save_path = get_unique_file_path(save_directory, file_name)

            with open(save_path, 'wb') as file:
                file.write(file_bytes)

            log_api_request(get_jwt_identity(), "Subida múltiple exitosa", file_path, file_name, 200)

        return jsonify({"message": "Archivos cargados correctamente"}), 200

    except ValueError as ve:
        log_api_request(get_jwt_identity(), "Intento de acceso no autorizado", file_path, "unknown", 403)
        return jsonify({"error": str(ve)}), 403
    except Exception as e:
        log_api_request(get_jwt_identity(), "Error en la subida múltiple", file_path, "unknown", 500, error_message=str(e))
        return jsonify({"error": "Error interno del servidor"}), 500

# Ruta para listar los archivos y carpetas en una ruta específica
@file_bp.route('/list', methods=['GET'])
@jwt_required()
def list_files_and_folders():
    user = get_current_user()
    if not user:
        return jsonify({"error": "Usuario no autenticado"}), 401

    dir_path = request.args.get('dirPath', '')

    try:
        user_directory = get_user_directory(user)
        target_directory = secure_path(user_directory, dir_path)

        if not os.path.exists(target_directory):
            return jsonify({"error": "El directorio no existe"}), 404

        directory_structure = get_directory_structure(Path(target_directory))

        return jsonify({"message": "Estructura obtenida correctamente", "structure": directory_structure}), 200

    except ValueError as ve:
        return jsonify({"error": str(ve)}), 403
    except Exception as e:
        return jsonify({"error": "Error interno del servidor"}), 500

# Ruta para descargar un archivo
@file_bp.route('/download', methods=['GET'])
@jwt_required()
def download_file():
    user = get_current_user()
    if not user:
        return jsonify({"error": "Usuario no autenticado"}), 401

    file_path = request.args.get('file_path')
    if not file_path:
        return jsonify({"error": "No se proporcionó la ruta del archivo"}), 400

    try:
        user_directory = get_user_directory(user)
        full_file_path = secure_path(user_directory, file_path)

        if not os.path.exists(full_file_path):
            return jsonify({"error": "El archivo no existe"}), 404

        return send_file(full_file_path, as_attachment=True)

    except ValueError as ve:
        return jsonify({"error": str(ve)}), 403
    except Exception as e:
        return jsonify({"error": "Error interno del servidor"}), 500

# Función para eliminar un archivo después de un retraso
def delayed_file_deletion(filepath, delay=180):
    time.sleep(delay)
    try:
        os.remove(filepath)
        print(f"Archivo {filepath} eliminado del servidor después de {delay} segundos.")
    except Exception as e:
        print(f"Error al eliminar el archivo {filepath}: {e}")

# Ruta para descargar una carpeta como ZIP
@file_bp.route('/download-folder', methods=['GET'])
@jwt_required()
def download_folder():
    user = get_current_user()
    if not user:
        return jsonify({"error": "Usuario no autenticado"}), 401

    folder_path = request.args.get('folder_path')
    if not folder_path:
        return jsonify({"error": "No se proporcionó la ruta de la carpeta"}), 400

    try:
        user_directory = get_user_directory(user)
        full_folder_path = secure_path(user_directory, folder_path)

        if not os.path.exists(full_folder_path):
            return jsonify({"error": "La carpeta no existe"}), 404

        # Crear directorio para ZIP si no existe
        if not os.path.exists(zip_path):
            os.makedirs(zip_path)

        # Nombre único para el archivo ZIP
        zip_filename = f"{os.path.basename(full_folder_path)}_{uuid.uuid4().hex}.zip"
        zip_filepath = os.path.join(zip_path, zip_filename)

        # Crear el archivo ZIP
        with zipfile.ZipFile(zip_filepath, 'w', zipfile.ZIP_DEFLATED) as zf:
            for root, dirs, files in os.walk(full_folder_path):
                for file in files:
                    full_file_path = os.path.join(root, file)
                    arcname = os.path.relpath(full_file_path, full_folder_path)
                    zf.write(full_file_path, arcname)

        # Programar eliminación del archivo ZIP
        @after_this_request
        def schedule_file_deletion(response):
            threading.Thread(target=delayed_file_deletion, args=(zip_filepath, 60)).start()
            return response

        return send_file(zip_filepath, as_attachment=True, download_name=os.path.basename(zip_filepath))

    except ValueError as ve:
        return jsonify({"error": str(ve)}), 403
    except Exception as e:
        return jsonify({"error": "Error interno del servidor"}), 500

# Ruta para crear una nueva carpeta
@file_bp.route('/create-folder', methods=['POST'])
@jwt_required()
def create_folder():
    user = get_current_user()
    if not user:
        return jsonify({"error": "Usuario no autenticado"}), 401

    data = request.get_json()
    folder_name = data.get('folder_name')
    parent_dir = data.get('parent_dir', '')

    if not folder_name:
        return jsonify({"error": "No se proporcionó el nombre de la carpeta"}), 400

    try:
        user_directory = get_user_directory(user)
        parent_directory = secure_path(user_directory, parent_dir)
        new_folder_path = os.path.join(parent_directory, folder_name)

        if os.path.exists(new_folder_path):
            return jsonify({"error": "La carpeta ya existe"}), 400

        os.makedirs(new_folder_path)
        return jsonify({"message": f"Carpeta '{folder_name}' creada exitosamente"}), 201

    except ValueError as ve:
        return jsonify({"error": str(ve)}), 403
    except Exception as e:
        return jsonify({"error": "Error interno del servidor"}), 500

# Ruta para mover archivos o carpetas
@file_bp.route('/move', methods=['POST'])
@jwt_required()
def move_file_or_folder():
    user = get_current_user()
    if not user:
        return jsonify({"error": "Usuario no autenticado"}), 401

    data = request.get_json()
    source_path = data.get('source_path')
    destination_path = data.get('destination_path')

    if not source_path or not destination_path:
        return jsonify({"error": "No se proporcionaron las rutas de origen o destino"}), 400

    try:
        user_directory = get_user_directory(user)
        full_source_path = secure_path(user_directory, source_path)
        full_destination_path = secure_path(user_directory, destination_path)

        if not os.path.exists(full_source_path):
            return jsonify({"error": "El archivo o carpeta de origen no existe"}), 404

        os.makedirs(os.path.dirname(full_destination_path), exist_ok=True)
        os.rename(full_source_path, full_destination_path)

        log_api_request(get_jwt_identity(), "Movimiento exitoso", "move", source_path, 200)
        return jsonify({"message": f"'{source_path}' movido exitosamente a '{destination_path}'"}), 200

    except ValueError as ve:
        return jsonify({"error": str(ve)}), 403
    except Exception as e:
        log_api_request(get_jwt_identity(), "Error al mover archivo/carpeta", "move", source_path, 500, error_message=str(e))
        return jsonify({"error": "Error interno del servidor"}), 500

# Ruta para eliminar un archivo o carpeta
@file_bp.route('/delete', methods=['POST'])
@jwt_required()
def delete_file_or_folder():
    user = get_current_user()
    if not user:
        return jsonify({"error": "Usuario no autenticado"}), 401

    data = request.get_json()
    target_path = data.get('target_path')

    if not target_path:
        return jsonify({"error": "No se proporcionó la ruta del archivo o carpeta a eliminar"}), 400

    try:
        user_directory = get_user_directory(user)
        full_target_path = secure_path(user_directory, target_path)

        if not os.path.exists(full_target_path):
            return jsonify({"error": "El archivo o carpeta no existe"}), 404

        if os.path.isfile(full_target_path):
            os.remove(full_target_path)
        else:
            os.rmdir(full_target_path)

        log_api_request(get_jwt_identity(), "Eliminación exitosa", "delete", target_path, 200)
        return jsonify({"message": f"'{target_path}' eliminado exitosamente"}), 200

    except ValueError as ve:
        return jsonify({"error": str(ve)}), 403
    except Exception as e:
        log_api_request(get_jwt_identity(), "Error al eliminar archivo/carpeta", "delete", target_path, 500, error_message=str(e))
        return jsonify({"error": "Error interno del servidor"}), 500

groups.py:
# 0.1 Operaciones relacionadas a grupos
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from sqlalchemy.exc import IntegrityError
from .db import Academy, Enrollment, Subject, db, Group, Semester, User, Student, Teacher
from .logs import log_api_request  
from .decorators import role_required  

# Crear el blueprint para grupos
groups_bp = Blueprint('groups', __name__)

# Función auxiliar para obtener el usuario actual
def get_current_user():
    identifier = get_jwt_identity()
    user = None

    # Buscar al usuario según el identificador
    student = Student.query.filter_by(boleta=identifier).first()
    if student:
        user = student.user
    else:
        teacher = Teacher.query.filter_by(rfc=identifier).first()
        if teacher:
            user = teacher.user
        else:
            academy = Academy.query.filter_by(academy_id=identifier).first()
            if academy:
                user = academy.main_teacher.user
            else:
                user = User.query.filter_by(id=identifier).first()  # Para administradores

    return user

# Endpoint para crear un nuevo grupo
@groups_bp.route('/create-group', methods=['POST'])
@jwt_required()  # Requiere autenticación con JWT
@role_required(0, 1)  # Administrador (0) y Academia (1)
def create_group():
    user = get_current_user()

    if not user:
        return jsonify({"error": "Usuario no encontrado"}), 404

    data = request.get_json()

    # Validar que se reciban los datos necesarios
    if not data or 'name' not in data or 'semester_id' not in data:
        log_api_request(user.id, "POST - Crear Grupo - Datos incompletos", 400)  # Log opcional
        return jsonify({"error": "Datos incompletos"}), 400

    try:
        # Verificar que el semestre exista
        semester = Semester.query.get(data['semester_id'])
        if not semester:
            log_api_request(user.id, f"POST - Crear Grupo - Semestre no encontrado (ID: {data['semester_id']})", 404)
            return jsonify({"error": "Semestre no encontrado"}), 404

        # Crear el nuevo grupo
        new_group = Group(
            name=data['name'],  # Nombre del grupo (ej. "6CV1")
            semester_id=data['semester_id']  # ID del semestre asociado
        )
        
        db.session.add(new_group)
        db.session.commit()

        log_api_request(user.id, f"POST - Grupo creado, ID: {new_group.id}, Nombre: {new_group.name}", 201)  # Log opcional
        return jsonify({"message": "Grupo creado exitosamente", "group_id": new_group.id}), 201

    except IntegrityError:
        db.session.rollback()
        log_api_request(user.id, "POST - Crear Grupo - Error de integridad", 500)  # Log opcional
        return jsonify({"error": "Error al crear el grupo"}), 500

    except Exception as e:
        db.session.rollback()
        log_api_request(user.id, f"POST - Crear Grupo - Error: {str(e)}", 500)  # Log opcional
        return jsonify({"error": str(e)}), 500

# Endpoint para crear un nuevo semestre
@groups_bp.route('/create-semester', methods=['POST'])
@jwt_required()  # Requiere autenticación con JWT
@role_required(0, 1)  # Administrador (0) y Academia (1)
def create_semester():
    user = get_current_user()

    if not user:
        return jsonify({"error": "Usuario no encontrado"}), 404

    data = request.get_json()

    # Validar que se reciban los datos necesarios
    if not data or 'semester' not in data:
        log_api_request(user.id, "POST - Crear Semestre - Datos incompletos", 400)  # Log opcional
        return jsonify({"error": "Datos incompletos"}), 400

    try:
        # Crear el nuevo semestre
        new_semester = Semester(
            semester=data['semester'],  # Nombre del semestre (ej. "2024-01")
            created_at=db.func.current_timestamp(),  # Fecha actual de creación
        )
        
        db.session.add(new_semester)
        db.session.commit()

        log_api_request(user.id, f"POST - Semestre creado, ID: {new_semester.id}, Nombre: {new_semester.semester}", 201)  # Log opcional
        return jsonify({"message": "Semestre creado exitosamente", "semester_id": new_semester.id}), 201

    except IntegrityError:
        db.session.rollback()
        log_api_request(user.id, "POST - Crear Semestre - Error de integridad", 500)  # Log opcional
        return jsonify({"error": "Error al crear el semestre"}), 500

    except Exception as e:
        db.session.rollback()
        log_api_request(user.id, f"POST - Crear Semestre - Error: {str(e)}", 500)  # Log opcional
        return jsonify({"error": str(e)}), 500
    
# Endpoint para crear una nueva materia
@groups_bp.route('/create-subject', methods=['POST'])
@jwt_required()  # Requiere autenticación con JWT
@role_required(0, 1)  # Administrador (0) y Academia (1)
def create_subject():
    user = get_current_user()

    if not user:
        return jsonify({"error": "Usuario no encontrado"}), 404

    data = request.get_json()

    # Validar que se reciban los datos necesarios
    required_fields = ['subject_name', 'academy_id', 'group_id', 'teacher_id']
    if not data or not all(field in data for field in required_fields):
        log_api_request(user.id, "POST - Crear Materia - Datos incompletos", 400)
        return jsonify({"error": "Datos incompletos"}), 400

    try:
        # Verificar que la academia exista
        academy = Academy.query.get(data['academy_id'])
        if not academy:
            log_api_request(user.id, f"POST - Crear Materia - Academia no encontrada (ID: {data['academy_id']})", 404)
            return jsonify({"error": "Academia no encontrada"}), 404

        # Verificar que el grupo exista
        group = Group.query.get(data['group_id'])
        if not group:
            log_api_request(user.id, f"POST - Crear Materia - Grupo no encontrado (ID: {data['group_id']})", 404)
            return jsonify({"error": "Grupo no encontrado"}), 404

        # Verificar que el profesor exista y tenga el rol adecuado
        teacher_user = User.query.get(data['teacher_id'])
        if not teacher_user or teacher_user.role_id != 2:  # Profesor tiene role_id = 2
            log_api_request(user.id, f"POST - Crear Materia - Profesor no encontrado o no válido (ID: {data['teacher_id']})", 404)
            return jsonify({"error": "Profesor no encontrado o no válido"}), 404

        # Crear la nueva materia
        new_subject = Subject(
            subject_name=data['subject_name'],  # Nombre de la materia
            academy_id=data['academy_id'],  # Academia asociada
            teacher_id=data['teacher_id'],  # Profesor asignado
            group_id=data['group_id'],  # Grupo al que pertenece la materia
            description=data.get('description', ''),  # Descripción opcional de la materia
            swift_scope=data.get('swift_scope', '')  # Swift scope opcional si es necesario
        )

        db.session.add(new_subject)
        db.session.commit()

        log_api_request(user.id, f"POST - Materia creada, ID: {new_subject.subject_id}, Nombre: {new_subject.subject_name}", 201)
        return jsonify({"message": "Materia creada exitosamente", "subject_id": new_subject.subject_id}), 201

    except IntegrityError:
        db.session.rollback()
        log_api_request(user.id, "POST - Crear Materia - Error de integridad", 500)
        return jsonify({"error": "Error al crear la materia"}), 500

    except Exception as e:
        db.session.rollback()
        log_api_request(user.id, f"POST - Crear Materia - Error: {str(e)}", 500)
        return jsonify({"error": str(e)}), 500
    
# Endpoint para crear una nueva academia
@groups_bp.route('/create-academy', methods=['POST'])
@jwt_required()  # Requiere autenticación con JWT
@role_required(0, 2)  # Administrador (0) y Profesor (2)
def create_academy():
    user = get_current_user()

    if not user:
        return jsonify({"error": "Usuario no encontrado"}), 404

    data = request.get_json()

    # Validar que se reciban los datos necesarios
    required_fields = ['name', 'main_teacher_id']
    if not data or not all(field in data for field in required_fields):
        log_api_request(user.id, "POST - Crear Academia - Datos incompletos", 400)
        return jsonify({"error": "Datos incompletos"}), 400

    try:
        # Verificar que el profesor principal (main_teacher) exista y sea un profesor
        main_teacher_user = User.query.get(data['main_teacher_id'])
        if not main_teacher_user or main_teacher_user.role_id != 2:  # Profesor tiene role_id = 2
            log_api_request(user.id, f"POST - Crear Academia - Profesor no encontrado o no válido (ID: {data['main_teacher_id']})", 404)
            return jsonify({"error": "Profesor principal no encontrado o no válido"}), 404

        # Crear la nueva academia
        new_academy = Academy(
            name=data['name'],  # Nombre de la academia
            description=data.get('description', ''),  # Descripción opcional
            main_teacher_id=data['main_teacher_id']  # Profesor principal asociado
        )

        db.session.add(new_academy)
        db.session.commit()

        log_api_request(user.id, f"POST - Academia creada, ID: {new_academy.academy_id}, Nombre: {new_academy.name}", 201)
        return jsonify({"message": "Academia creada exitosamente", "academy_id": new_academy.academy_id}), 201

    except IntegrityError:
        db.session.rollback()
        log_api_request(user.id, "POST - Crear Academia - Error de integridad", 500)
        return jsonify({"error": "Error al crear la academia"}), 500

    except Exception as e:
        db.session.rollback()
        log_api_request(user.id, f"POST - Crear Academia - Error: {str(e)}", 500)
        return jsonify({"error": str(e)}), 500
    
# Endpoint para crear una nueva inscripción
@groups_bp.route('/enroll', methods=['POST'])
@jwt_required()  # Requiere autenticación con JWT
@role_required(0, 1)  # Administrador (0) y Academia (1)
def create_enrollment():
    user = get_current_user()

    if not user:
        return jsonify({"error": "Usuario no encontrado"}), 404

    data = request.get_json()

    # Validar que se reciban los datos necesarios
    required_fields = ['user_id', 'subject_id']
    if not data or not all(field in data for field in required_fields):
        log_api_request(user.id, "POST - Crear Inscripción - Datos incompletos", 400)
        return jsonify({"error": "Datos incompletos"}), 400

    try:
        # Verificar que el estudiante exista
        student_user = User.query.get(data['user_id'])
        if not student_user or student_user.role_id != 3:  # Estudiante tiene role_id = 3
            log_api_request(user.id, f"POST - Crear Inscripción - Estudiante no encontrado o no válido (ID: {data['user_id']})", 404)
            return jsonify({"error": "Estudiante no encontrado o no válido"}), 404

        # Verificar que la materia exista
        subject = Subject.query.get(data['subject_id'])
        if not subject:
            log_api_request(user.id, f"POST - Crear Inscripción - Materia no encontrada (ID: {data['subject_id']})", 404)
            return jsonify({"error": "Materia no encontrada"}), 404

        # Verificar si la inscripción ya existe
        existing_enrollment = Enrollment.query.filter_by(user_id=data['user_id'], subject_id=data['subject_id']).first()
        if existing_enrollment:
            log_api_request(user.id, f"POST - Crear Inscripción - Inscripción ya existe para el estudiante {data['user_id']} en la materia {data['subject_id']}", 400)
            return jsonify({"error": "El estudiante ya está inscrito en esta materia"}), 400

        # Crear la nueva inscripción
        new_enrollment = Enrollment(
            user_id=data['user_id'],  # ID del estudiante
            subject_id=data['subject_id'],  # ID de la materia
            status=data.get('status', 'active')  # Estado de la inscripción (por defecto 'active')
        )

        db.session.add(new_enrollment)
        db.session.commit()

        log_api_request(user.id, f"POST - Inscripción creada para el estudiante {data['user_id']} en la materia {data['subject_id']}", 201)
        return jsonify({"message": "Inscripción creada exitosamente", "enrollment_id": new_enrollment.enrollment_id}), 201

    except IntegrityError:
        db.session.rollback()
        log_api_request(user.id, "POST - Crear Inscripción - Error de integridad", 500)
        return jsonify({"error": "Error al crear la inscripción"}), 500

    except Exception as e:
        db.session.rollback()
        log_api_request(user.id, f"POST - Crear Inscripción - Error: {str(e)}", 500)
        return jsonify({"error": str(e)}), 500

users.py:
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from werkzeug.security import generate_password_hash
from sqlalchemy.exc import IntegrityError
from .db import Role, db, User, Student, Teacher, Academy
from .logs import log_api_request
from .decorators import role_required

users_bp = Blueprint('users', __name__)

# Función auxiliar para obtener el usuario actual basado en el identificador
def get_current_user():
    identifier = get_jwt_identity()
    user = None

    # Buscar al usuario según el identificador
    student = Student.query.filter_by(boleta=identifier).first()
    if student:
        user = student.user
    else:
        teacher = Teacher.query.filter_by(rfc=identifier).first()
        if teacher:
            user = teacher.user
        else:
            academy = Academy.query.filter_by(academy_id=identifier).first()
            if academy:
                user = academy.main_teacher.user
            else:
                # Asumimos que los administradores se autentican con user.id
                user = User.query.filter_by(id=identifier, role_id=0).first()

    return user

# Registrar un nuevo usuario
@users_bp.route('/', methods=['POST'])
@jwt_required()
@role_required(0, 1)  # Solo Administrador (0) o Academia (1)
def add_user():
    current_user = get_current_user()

    data = request.get_json()

    # Validar datos requeridos
    required_fields = ['username', 'email', 'password', 'role_id']
    if not data or not all(field in data for field in required_fields):
        log_api_request(get_jwt_identity(), 'POST - Agregar Usuario - Datos incompletos', "users", "none", 400)
        return jsonify({"error": "Datos incompletos"}), 400

    # Verificar si el rol existe
    role_id = data['role_id']
    existing_role = Role.query.get(role_id)
    if existing_role is None:
        log_api_request(get_jwt_identity(), 'POST - Agregar Usuario - Rol inexistente', "users", "none", 400)
        return jsonify({"error": f"El rol con ID {role_id} no existe."}), 400

    hashed_password = generate_password_hash(data['password'])
    new_user = User(
        username=data['username'],
        email=data['email'],
        password=hashed_password,
        active=True,
        role_id=role_id
    )

    try:
        db.session.add(new_user)
        db.session.commit()

        # Si el usuario es un estudiante o profesor, crear los registros correspondientes
        if role_id == 3:  # Estudiante
            if 'boleta' not in data:
                log_api_request(get_jwt_identity(), 'POST - Agregar Usuario - Boleta requerida para estudiantes', "users", "none", 400)
                return jsonify({"error": "El campo 'boleta' es obligatorio para estudiantes."}), 400
            new_student = Student(
                user_id=new_user.id,
                boleta=data['boleta'],
                current_semester=data.get('current_semester')
            )
            db.session.add(new_student)
            db.session.commit()
        elif role_id == 2:  # Profesor
            if 'rfc' not in data:
                log_api_request(get_jwt_identity(), 'POST - Agregar Usuario - RFC requerido para profesores', "users", "none", 400)
                return jsonify({"error": "El campo 'rfc' es obligatorio para profesores."}), 400
            new_teacher = Teacher(
                user_id=new_user.id,
                rfc=data['rfc']
            )
            db.session.add(new_teacher)
            db.session.commit()

        log_api_request(get_jwt_identity(), 'POST - Usuario creado con éxito', "users", "none", 201)
        return jsonify({"message": "Usuario creado con éxito"}), 201
    except IntegrityError as e:
        db.session.rollback()
        if 'UNIQUE constraint failed' in str(e.orig):
            log_api_request(get_jwt_identity(), 'POST - Error - Username o email en uso', "users", "none", 400)
            return jsonify({"error": "El nombre de usuario o email ya está en uso."}), 400
        else:
            log_api_request(get_jwt_identity(), 'POST - Error al crear usuario', "users", "none", 500)
            return jsonify({"error": "Error al crear el usuario."}), 500
    except Exception as e:
        db.session.rollback()
        log_api_request(get_jwt_identity(), 'POST - Error general', "users", "none", 500, error_message=str(e))
        return jsonify({"error": str(e)}), 500

# Obtener todos los usuarios
@users_bp.route('/', methods=['GET'])
@jwt_required()
@role_required(0, 1)  # Solo Administrador (0) o Academia (1)
def get_users():
    current_user = get_current_user()
    users = User.query.all()
    log_api_request(get_jwt_identity(), 'GET - Obtener todos los usuarios', "users", "none", 200)
    users_data = []
    for user in users:
        user_info = {
            'username': user.username,
            'email': user.email,
            'role': user.role.name
        }
        if user.role_id == 3 and user.student:
            user_info['boleta'] = user.student.boleta
        if user.role_id == 2 and user.teacher:
            user_info['rfc'] = user.teacher.rfc
        users_data.append(user_info)
    return jsonify(users_data), 200

# Obtener un usuario por identificador
@users_bp.route('/<identifier>', methods=['GET'])
@jwt_required()
@role_required(0, 1)  # Solo Administrador (0) o Academia (1)
def get_user(identifier):
    current_user = get_current_user()
    user = None

    # Buscar al usuario según el identificador
    student = Student.query.filter_by(boleta=identifier).first()
    if student:
        user = student.user
    else:
        teacher = Teacher.query.filter_by(rfc=identifier).first()
        if teacher:
            user = teacher.user
        else:
            # No se puede obtener un administrador o academia por identificador en este endpoint
            return jsonify({"error": "Usuario no encontrado"}), 404

    if user is None:
        log_api_request(get_jwt_identity(), 'GET - Usuario no encontrado', "users", identifier, 404)
        return jsonify({"error": "Usuario no encontrado"}), 404

    log_api_request(get_jwt_identity(), 'GET - Usuario encontrado', "users", identifier, 200)
    user_info = {
        'username': user.username,
        'email': user.email,
        'role': user.role.name
    }
    if user.role_id == 3 and user.student:
        user_info['boleta'] = user.student.boleta
    if user.role_id == 2 and user.teacher:
        user_info['rfc'] = user.teacher.rfc

    return jsonify(user_info), 200

# Actualizar un usuario
@users_bp.route('/<identifier>', methods=['PUT'])
@jwt_required()
@role_required(0, 1)
def update_user(identifier):
    current_user = get_current_user()
    data = request.get_json()
    user = None

    # Buscar al usuario según el identificador
    student = Student.query.filter_by(boleta=identifier).first()
    if student:
        user = student.user
    else:
        teacher = Teacher.query.filter_by(rfc=identifier).first()
        if teacher:
            user = teacher.user
        else:
            # No se puede actualizar un administrador o academia por identificador en este endpoint
            return jsonify({"error": "Usuario no encontrado"}), 404

    if user is None:
        log_api_request(get_jwt_identity(), 'PUT - Usuario no encontrado', "users", identifier, 404)
        return jsonify({"error": "Usuario no encontrado"}), 404

    # Actualizar solo los campos proporcionados
    if 'email' in data and data['email']:
        user.email = data['email']
    if 'username' in data and data['username']:
        user.username = data['username']
    if 'password' in data and data['password']:
        user.password = generate_password_hash(data['password'])
    # No se permite cambiar el role_id directamente
    if user.role_id == 3 and 'boleta' in data and data['boleta']:
        user.student.boleta = data['boleta']
    if user.role_id == 2 and 'rfc' in data and data['rfc']:
        user.teacher.rfc = data['rfc']

    db.session.commit()
    log_api_request(get_jwt_identity(), 'PUT - Usuario actualizado con éxito', "users", identifier, 200)
    return jsonify({"message": "Usuario actualizado con éxito"}), 200

# Eliminar un usuario
@users_bp.route('/<identifier>', methods=['DELETE'])
@jwt_required()
@role_required(0)
def delete_user(identifier):
    current_user = get_current_user()
    user = None

    # Buscar al usuario según el identificador
    student = Student.query.filter_by(boleta=identifier).first()
    if student:
        user = student.user
    else:
        teacher = Teacher.query.filter_by(rfc=identifier).first()
        if teacher:
            user = teacher.user
        else:
            # No se puede eliminar un administrador o academia por identificador en este endpoint
            return jsonify({"error": "Usuario no encontrado"}), 404

    if user is None:
        log_api_request(get_jwt_identity(), 'DELETE - Usuario no encontrado', "users", identifier, 404)
        return jsonify({"error": "Usuario no encontrado"}), 404

    # Eliminar registros asociados
    if user.role_id == 3 and user.student:
        db.session.delete(user.student)
    if user.role_id == 2 and user.teacher:
        db.session.delete(user.teacher)

    db.session.delete(user)
    db.session.commit()
    log_api_request(get_jwt_identity(), 'DELETE - Usuario eliminado', "users", identifier, 200)
    return jsonify({"message": "Usuario eliminado con éxito"}), 200

# Obtener los datos públicos del usuario autenticado
@users_bp.route('/info', methods=['GET'])
@jwt_required()
def info_user():
    current_user = get_current_user()

    if current_user is None:
        return jsonify({"error": "Usuario no encontrado"}), 404

    # Construir la respuesta según el rol del usuario
    user_info = {
        "username": current_user.username,
        "email": current_user.email,
        "role": current_user.role.name
    }

    if current_user.role_id == 3 and current_user.student:
        user_info["boleta"] = current_user.student.boleta
    if current_user.role_id == 2 and current_user.teacher:
        user_info["rfc"] = current_user.teacher.rfc

    return jsonify(user_info), 200

# ------------------------------
# Endpoints para Gestión de Academias
# ------------------------------

# Crear una nueva academia
@users_bp.route('/academies', methods=['POST'])
@jwt_required()
@role_required(0)  # Solo administradores pueden crear academias
def create_academy():
    current_user = get_current_user()
    data = request.get_json()

    # Validar datos requeridos
    required_fields = ['name', 'main_teacher_rfc']
    if not data or not all(field in data for field in required_fields):
        log_api_request(get_jwt_identity(), 'POST - Crear Academia - Datos incompletos', "academies", "none", 400)
        return jsonify({"error": "Datos incompletos"}), 400

    # Verificar que el profesor principal exista y sea un profesor
    main_teacher = Teacher.query.filter_by(rfc=data['main_teacher_rfc']).first()
    if not main_teacher:
        log_api_request(get_jwt_identity(), 'POST - Crear Academia - Profesor principal no encontrado', "academies", "none", 404)
        return jsonify({"error": "Profesor principal no encontrado"}), 404

    # Crear la nueva academia
    new_academy = Academy(
        name=data['name'],
        description=data.get('description', ''),
        main_teacher_id=main_teacher.user_id  # Asignar el user_id del profesor principal
    )

    try:
        db.session.add(new_academy)
        db.session.commit()
        log_api_request(get_jwt_identity(), 'POST - Academia creada con éxito', "academies", str(new_academy.academy_id), 201)
        return jsonify({"message": "Academia creada con éxito", "academy_id": new_academy.academy_id}), 201
    except IntegrityError as e:
        db.session.rollback()
        log_api_request(get_jwt_identity(), 'POST - Error al crear academia', "academies", "none", 500)
        return jsonify({"error": "Error al crear la academia."}), 500
    except Exception as e:
        db.session.rollback()
        log_api_request(get_jwt_identity(), 'POST - Error general', "academies", "none", 500, error_message=str(e))
        return jsonify({"error": str(e)}), 500

# Obtener todas las academias
@users_bp.route('/academies', methods=['GET'])
@jwt_required()
@role_required(0, 1)  # Administradores y academias pueden acceder
def get_academies():
    current_user = get_current_user()
    academies = Academy.query.all()
    log_api_request(get_jwt_identity(), 'GET - Obtener todas las academias', "academies", "none", 200)
    academies_data = [{
        'academy_id': academy.academy_id,
        'name': academy.name,
        'description': academy.description,
        'main_teacher_rfc': academy.main_teacher.teacher.rfc  # Obtener el RFC del profesor principal
    } for academy in academies]
    return jsonify(academies_data), 200

# Obtener una academia por ID
@users_bp.route('/academies/<int:academy_id>', methods=['GET'])
@jwt_required()
@role_required(0, 1)
def get_academy(academy_id):
    current_user = get_current_user()
    academy = Academy.query.get(academy_id)
    if not academy:
        log_api_request(get_jwt_identity(), 'GET - Academia no encontrada', "academies", str(academy_id), 404)
        return jsonify({"error": "Academia no encontrada"}), 404

    log_api_request(get_jwt_identity(), 'GET - Academia encontrada', "academies", str(academy_id), 200)
    academy_data = {
        'academy_id': academy.academy_id,
        'name': academy.name,
        'description': academy.description,
        'main_teacher_rfc': academy.main_teacher.teacher.rfc
    }
    return jsonify(academy_data), 200

# Actualizar una academia
@users_bp.route('/academies/<int:academy_id>', methods=['PUT'])
@jwt_required()
@role_required(0, 1)
def update_academy(academy_id):
    current_user = get_current_user()
    data = request.get_json()
    academy = Academy.query.get(academy_id)
    if not academy:
        log_api_request(get_jwt_identity(), 'PUT - Academia no encontrada', "academies", str(academy_id), 404)
        return jsonify({"error": "Academia no encontrada"}), 404

    # Actualizar campos proporcionados
    if 'name' in data and data['name']:
        academy.name = data['name']
    if 'description' in data:
        academy.description = data['description']
    if 'main_teacher_rfc' in data and data['main_teacher_rfc']:
        # Verificar que el nuevo profesor principal exista
        main_teacher = Teacher.query.filter_by(rfc=data['main_teacher_rfc']).first()
        if not main_teacher:
            return jsonify({"error": "Profesor principal no encontrado"}), 404
        academy.main_teacher_id = main_teacher.user_id

    db.session.commit()
    log_api_request(get_jwt_identity(), 'PUT - Academia actualizada con éxito', "academies", str(academy_id), 200)
    return jsonify({"message": "Academia actualizada con éxito"}), 200

# Eliminar una academia
@users_bp.route('/academies/<int:academy_id>', methods=['DELETE'])
@jwt_required()
@role_required(0)  # Solo administradores pueden eliminar academias
def delete_academy(academy_id):
    current_user = get_current_user()
    academy = Academy.query.get(academy_id)
    if not academy:
        log_api_request(get_jwt_identity(), 'DELETE - Academia no encontrada', "academies", str(academy_id), 404)
        return jsonify({"error": "Academia no encontrada"}), 404

    db.session.delete(academy)
    db.session.commit()
    log_api_request(get_jwt_identity(), 'DELETE - Academia eliminada', "academies", str(academy_id), 200)
    return jsonify({"message": "Academia eliminada con éxito"}), 200

# Obtener información de la academia autenticada
@users_bp.route('/academies/info', methods=['GET'])
@jwt_required()
@role_required(1)  # Solo academias pueden acceder
def info_academy():
    current_user = get_current_user()
    academy = Academy.query.filter_by(academy_id=get_jwt_identity()).first()
    if not academy:
        return jsonify({"error": "Academia no encontrada"}), 404

    academy_data = {
        'academy_id': academy.academy_id,
        'name': academy.name,
        'description': academy.description,
        'main_teacher_rfc': academy.main_teacher.teacher.rfc
    }
    return jsonify(academy_data), 200

__init__.py:
# app/__init__.py
from flask import Flask
from flask_cors import CORS
from flask_jwt_extended import JWTManager
from flask_migrate import Migrate
from datetime import timedelta
from .db import init_db, db, User

# Importa y registra los Blueprints
from .users import users_bp
from .auth import auth_bp
from .file import file_bp
from .groups import groups_bp
from .events import logs_bp


def create_app():
    app = Flask(__name__)
    CORS(app, supports_credentials=True)  # Permite el uso de credenciales
    
    # Configuración de la base de datos
    app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://root:root@localhost/test'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False


    app.config['MAX_CONTENT_LENGTH'] = 10 * 1024 * 1024 * 1024  # 1 GB
    # Establece la clave secreta para firmar JWT
    app.config['JWT_SECRET_KEY'] = 'd822d96ef56c589c3904a372381fa378'  # Cambia esto por una clave secreta única
    app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(days=2)  # Duración de los tokens de 2 dias
    # Inicializa Migrate
    migrate = Migrate(app, db)
    
    # Inicializa la base de datos
    init_db(app)

    # Inicializa JWTManager
    jwt = JWTManager(app)

    # Registra los blueprints
    app.register_blueprint(users_bp, url_prefix='/users')
    app.register_blueprint(auth_bp, url_prefix='/auth')
    app.register_blueprint(file_bp, url_prefix='/file')
    app.register_blueprint(groups_bp, url_prefix='/groups')
    app.register_blueprint(logs_bp, url_prefix='/logs')

    #inicializar openstack auth_openstack
    return app
